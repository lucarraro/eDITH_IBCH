rm(list=ls())
library(rivnet)
library(OCNet)
library(Rcpp)
library(terra)
library(BayesianTools)
library(LaplacesDemon)
library(readxl)
library(fields)
library(investr) # draw trendline using plotFit
library(eDITH)

source("support/support_functions.R")
load("support/Thur.rda")
load("support/eDNASamplingSitesInfo.rda")

createFigures <- F # set to TRUE to generate figures 

# load eDNA data and summarize eDITH model results ####
allData <- read.csv("data/MZBTaxa_summed.csv") # pooled
familyNames <- as.vector(allData["Family"]); familyNames <- familyNames$Family
allData <- allData[ ,-1]
row.names(allData) <- familyNames
allData <- as.data.frame(t(allData))
familyRichnessData <- rowSums(allData>0)


if (!file.exists("results/results_compact.rda")){
  load("results/Tipulidae.rda") # will be generated by run_eDITH.R
  n.par <- length(out$param_map)
  gD_psrf <- MAP_estimates <- cI_low <- cI_high <- matrix(0, n.par, length(familyNames))
  gD_mpsrf <- numeric(length(familyNames))
  colnames(gD_psrf) <- colnames(MAP_estimates) <- colnames(cI_low) <- colnames(cI_high) <- familyNames
  rownames(gD_psrf) <- rownames(MAP_estimates) <- rownames(cI_low) <- rownames(cI_high) <- names(out$param_map)
  names(gD_mpsrf) <- familyNames
  familiesPerReach <- vector("list",Thur$AG$nNodes)
  familyRichness <- numeric(Thur$AG$nNodes)
  probDet_all <- p_all <- data.frame(matrix(0,Thur$AG$nNodes,length(familyNames)))
  colnames(probDet_all) <- colnames(p_all) <- familyNames
  for (ff in familyNames){
    cat(sprintf('%d) %s  \n',which(familyNames==ff),ff))
    if(file.exists(paste0("results/",ff,".rda"))){
      load(paste0('results/',ff,'.rda'))
      gD_psrf[, ff] <- out$gD$psrf[,1]
      gD_mpsrf[ff] <- out$gD$mpsrf
      MAP_estimates[, ff] <- out$param_map
      cI_low[, ff] <- out$cI[1,1:n.par]
      cI_high[, ff] <- out$cI[2,1:n.par]
      probDet_all[[ff]] <- out$probDetection_quantile
      p_all[[ff]] <- out$p_quantile
      PA <- out$probDetection_quantile>=0.5
      familyRichness <- familyRichness + as.numeric(PA)
      for (i in which(PA)){
        familiesPerReach[[i]] <- c(familiesPerReach[[i]], ff)
      }
    }
  }
  cov.low  <- cI_high[3:(n.par-1),]<0
  cov.high <- cI_low[3:(n.par-1),]>0
  save(cov.low,cov.high,MAP_estimates,gD_psrf,gD_mpsrf,
       familyRichness,familiesPerReach,cI_low,cI_high,
       probDet_all,p_all,file="results/results_compact.rda")
} else {load("results/results_compact.rda")}

# assess predicted IBCH ####
IBCH.value <- IBCH.DK <- IBCH.GI <- numeric(Thur$AG$nNodes)
IBCH.color <- vector("character",Thur$AG$nNodes)
for (i in 1:Thur$AG$nNodes){
  tmp <- assign_IBCH(familiesPerReach[[i]])
  IBCH.value[i] <- tmp$IBCH.value
  IBCH.color[i] <- tmp$IBCH.color
  IBCH.DK[i] <- tmp$DK
  IBCH.GI[i] <- tmp$GI
}
IBCH.cat <- numeric(Thur$AG$nNodes)
IBCH.cat[IBCH.color=="red"] <- 1
IBCH.cat[IBCH.color=="orange"] <- 2
IBCH.cat[IBCH.color=="yellow"] <- 3
IBCH.cat[IBCH.color=="green"] <- 4
IBCH.cat[IBCH.color=="blue"] <- 5


# read and process river habitat status data from Canton St. Gallen ####
oeko_shp <- sf::st_read("data/OM_ABSCH_OEKOMORPH_2013_L.shp", quiet=T)
oeko_shp <- sf::st_transform(oeko_shp, "EPSG:21781") # convert to LV03
oeko1 <- oeko_shp["OEKOMKLASS"]
tmp <- NA*numeric(dim(oeko_shp)[1])
tmp[oeko1$OEKOMKLASS=="nicht_bestimmt"] <- 1
tmp[oeko1$OEKOMKLASS=="eingedolt"] <- 2
tmp[oeko1$OEKOMKLASS=="naturfremd_künstlich"] <- 3
tmp[oeko1$OEKOMKLASS=="stark_beeinträchtigt"] <- 4
tmp[oeko1$OEKOMKLASS=="wenig_beeinträchtigt"] <- 5
tmp[oeko1$OEKOMKLASS=="natürlich_naturnah"] <- 6
oeko1$OEKOMKLASS <- tmp

# read and process river habitat status data from BAFU ####
if (!file.exists("support/oeko_data.rda")){
  # download the shp below from https://www.bafu.admin.ch/bafu/de/home/zustand/daten/geodaten/wasser--geodaten.html
  oeko_BAFU_shp <- sf::st_read("data/om_abschnitte_gwl2507.shp", quiet=T)
  oeko_BAFU_shp <- sf::st_zm(oeko_BAFU_shp)

  oeko2 <- oeko_BAFU_shp["OEKOMKLASS"]
  oeko2$OEKOMKLASS[oeko2$OEKOMKLASS==1] <- 1006
  oeko2$OEKOMKLASS[oeko2$OEKOMKLASS==2] <- 1005
  oeko2$OEKOMKLASS[oeko2$OEKOMKLASS==3] <- 1004
  oeko2$OEKOMKLASS[oeko2$OEKOMKLASS==4] <- 1003
  oeko2$OEKOMKLASS[oeko2$OEKOMKLASS==5] <- 1002
  oeko2$OEKOMKLASS <- oeko2$OEKOMKLASS - 1000
  oeko <- rbind(oeko1, oeko2)
  n.features <- dim(oeko)[1]

  rangeX <- range(Thur$CM$XContour[[1]][[1]])
  rangeY <- range(Thur$CM$YContour[[1]][[1]])
  retainFeature <- logical(n.features)
  lengthFeature <- numeric(n.features)
  for (i in 1:n.features){
    gg <- oeko$geometry[i][[1]]
    lengthFeature[i] <- dim(as.matrix(gg))[1]
    center <- colMeans(as.matrix(gg))
    dist <- sqrt((center[1]-Thur$FD$X)^2 + (center[2]-Thur$FD$Y)^2) # distance from any point in the catchment
    if (min(dist)< 3*Thur$cellsize){retainFeature[i] <- TRUE}
  }
  # alternative, unsupervised assignment
  attribute.feature.AG <- numeric(n.features)
  features.inside <- which(retainFeature)
  for (i in features.inside){
    gg <- oeko$geometry[i][[1]]
    ll <- locate_site(colMeans(gg)[1],colMeans(gg)[2],Thur)
    if (ll$distance <= 100) attribute.feature.AG[i] <- ll$AGnode
    if ((i %% 10)==0) cat(sprintf("%.2f%% done \r", i/n.features*100))
  }
  features4comparison <- which(attribute.feature.AG>0)
  featureToAG <- attribute.feature.AG[attribute.feature.AG>0]
  save(retainFeature, features4comparison, featureToAG, oeko, file="support/oeko_data.rda")
} else {load("support/oeko_data.rda")}
Oekomorph.val <- oeko$OEKOMKLASS[features4comparison]


# measured IBCH values and location of sites ####
measured.IBCH.data <- read.csv(file="data/MZBSites_IBCH.csv")
measured.IBCH.data$X <- as.numeric(gsub("'","",measured.IBCH.data$Koordinaten)) - 2e6
measured.IBCH.data$Y <- as.numeric(gsub("'","",measured.IBCH.data$Koordinaten.1)) - 1e6
tmp <- numeric(dim(measured.IBCH.data)[1])
tmp[measured.IBCH.data$Beurteilung...IBCH=="sehr gut"] <- 5
tmp[measured.IBCH.data$Beurteilung...IBCH=="gut"] <- 4
tmp[measured.IBCH.data$Beurteilung...IBCH=="mässig"] <- 3
tmp[measured.IBCH.data$Beurteilung...IBCH=="unbefriedigend"] <- 2
measured.IBCH.data$IBCH_5 <- tmp

# adjust sites' coordinates to make sure that they pinpoint the right location in the extracted river network
measured.IBCH.data$X[3] <- 723800; measured.IBCH.data$Y[3] <- 247000
measured.IBCH.data$X[5] <- 722000; measured.IBCH.data$Y[5] <- 257000 
measured.IBCH.data$Y[11] <- 256200
measured.IBCH.data$X[12] <- 733200;
measured.IBCH.data$X[15] <- 734500;   measured.IBCH.data$Y[15] <- 252600
measured.IBCH.data$Y[16] <- 252700
measured.IBCH.data$X[17] <- 735500;   measured.IBCH.data$Y[17] <- 255900
measured.IBCH.data$Y[18] <- 256000
measured.IBCH.data$Y[19] <- 252600
measured.IBCH.data$Y[25] <- 253750
measured.IBCH.data$AGnode <- numeric(length(measured.IBCH.data$X))
for (i in 1:length(measured.IBCH.data$X)){
  ll <- rivnet::locate_site(measured.IBCH.data$X[i], measured.IBCH.data$Y[i], Thur, showPlot=F)
  #title(sprintf("%d. -  X: %d - Y: %d", i, measured.IBCH.data$X[i], measured.IBCH.data$Y[i]))
  measured.IBCH.data$AGnode[i] <- ll$AGnode
  measured.IBCH.data$RNnode[i] <- ll$RNnode
  #readline("Press [enter] to continue: ")
}
measured.IBCH.data$IBCH_20 <- measured.IBCH.data$IBCH..Index.wirbellose.Wassertiere.
measured.IBCH.data$IBCH_20[which(is.na(measured.IBCH.data$IBCH_20))] <- c(13,17) # mid-value from respective class to fill in NA values


# read and process kick-net dataset from Canton St. Gallen ####
bio <- read_xlsx('data/BIO-DB-AUSWERTUNG.xlsx')       # part 1
fliess <- read_xlsx("data/FliessgewässerSG2017.xlsx") # part 2 (contains info for sites OGT150, OGT069 that is missing from the file above) 
fliess <- fliess[fliess$OID=="OGT150" | fliess$OID=="OGT069",] # subset to the missing sites
# merge rows for observations of the same taxon
bio.noRep <- data.frame(matrix(0,1,ncol(bio)))
names(bio.noRep) <- names(bio)
k <- 1; bin <- NULL
for (i in 1:nrow(bio)){
  if (!(i %in% bin) ){
    tmp1 <- which(bio$MST_CODE==bio$MST_CODE[i])
    tmp2 <- which(bio$VT==bio$VT[i])
    tmp <- intersect(tmp1, tmp2)
    bin <- unique(c(bin, tmp))
    bio.noRep[k, ] <- bio[i, ]
    bio.noRep$Anzahl[k] <- sum(bio$Anzahl[tmp])
    k <- k+1
  }
}
fliess.noRep <- data.frame(matrix(0,1,ncol(fliess)))
names(fliess.noRep) <- names(fliess)
k <- 1; bin <- NULL
for (i in 1:nrow(fliess)){
  if (!(i %in% bin) ){
    tmp1 <- which(fliess$OID==fliess$OID[i])
    tmp2 <- which(fliess$VT==fliess$VT[i])
    tmp <- intersect(tmp1, tmp2)
    bin <- unique(c(bin, tmp))
    fliess.noRep[k, ] <- fliess[i, ]
    fliess.noRep$FREQ1[k] <- sum(fliess$FREQ1[tmp])
    k <- k+1
  }
}
df.SG <- data.frame(ID=c(bio.noRep$MST_CODE, fliess.noRep$OID),
                    VT=c(bio.noRep$VT, fliess.noRep$VT),
                    N=c(bio.noRep$Anzahl, fliess.noRep$FREQ1))
nSitesSG <- length(unique(df.SG$ID))

# dataSG: data frame of recorded abundance per site and taxon
dataSG <- data.frame(matrix(0,nSitesSG,length(familyNames)))
names(dataSG) <- familyNames
row.names(dataSG) <- unique(measured.IBCH.data$Kurzbezeichnung)
for (j in 1:nrow(df.SG)){
  for (ff in familyNames){
    if (ff %in% df.SG[j,]){
      site <- df.SG$ID[j]
      dataSG[site,][[ff]] <- dataSG[site,][[ff]] + df.SG$N[j]
    }
  }
}

dataSG.PA <- dataSG.PA.noThr <-as.data.frame(dataSG>0)
# dataSG.PA counts only families above the threshold for IBCH calculation; dataSG.PA.noThr has all taxa found (thr=1)
for(ff in familyNames){
  if (ff %in% c("Limnephilidae", "Ephemerellidae", "Baetidae","Caenidae" ,"Elmidae",
                "Gammaridae", "Chironomidae", "Asellidae","Oligochaeta") ){
    dataSG.PA[[ff]] <- dataSG[[ff]]>=10
  } else { dataSG.PA[[ff]] <- dataSG[[ff]]>=3}
}

# break down taxon-based P/A predictions into TP, TN, FP, FN ####
predictionBreakdown <- data.frame(matrix(0,length(familyNames),4))
row.names(predictionBreakdown) <- familyNames
names(predictionBreakdown) <- c("TP","TN","FP","FN")
for (ff in familyNames){
  TrueModel <- probDet_all[[ff]][measured.IBCH.data$AGnode]>0.5
  TrueData <- dataSG.PA[[ff]]
  out <- eval.TP.FP(TrueModel, TrueData, discardSite=20)
  predictionBreakdown[ff,] <- c(out$TP, out$TN, out$FP, out$FN)/sum(out$TP + out$TN + out$FP + out$FN)
}
predictionBreakdown[,"familyNames"] <- familyNames

# compare predicted IBCH and river habitat status ####
IBCH20.4comparison <- IBCH.value[featureToAG]
compare.mat20 <- matrix(0,6,20)
for (i in 1:6){
  for (j in 1:20){
    compare.mat20[i,j] <- sum(Oekomorph.val==i & IBCH20.4comparison ==j)
  }
}
compare.mat20 <- compare.mat20/sum(compare.mat20)
lmod20 <- lm(Oekomorph.val[Oekomorph.val>2] ~ IBCH20.4comparison[Oekomorph.val>2]); ss20 <- summary(lmod20)

# bootstrap-based estimation of CI for river habitat status ~ predicted IBCH regression ####
x <- IBCH20.4comparison[Oekomorph.val>2]
y <- Oekomorph.val[Oekomorph.val>2]
slopes <- intercept <- numeric(10000)
for (i in 1:10000){
  sam <- sample(1:length(y), round(length(y))/10, replace=T)
  sx <- summary(lm(y[sam] ~ x[sam]))
  slopes[i] <- sx$coefficients[2,1]
  intercept[i] <- sx$coefficients[1,1]
}
x_val <- seq(0,18,0.1)
mm <- matrix(0,10000,length(x_val))
for (i in 1:10000){ mm[i,] <- slopes[i]*x_val + intercept[i]}
qq <- apply(mm,2,quantile,probs=c(0.025,0.975))

# Sensitivity analysis on threshold value for P/A prediction #### 
qq_values <- seq(0.1,0.9,0.1)
correctPredictions <- data.frame(matrix(0,length(qq_values),length(familyNames)))
names(correctPredictions) <- familyNames
rownames(correctPredictions) <- qq_values
for (ff in familyNames){
  for (q in 1:length(qq_values)){
    correctPredictions[[ff]][q] <-
      sum(as.numeric(probDet_all[[ff]][measured.IBCH.data$AGnode]>qq_values[q])==
            as.numeric(dataSG.PA[[ff]]))/nrow(dataSG)}}

# create figures ####
if (createFigures){ # Fig. 2
  pdf(file="Fig2.pdf", width=36/2.54,height=18/2.54)
  aa <- sort(10.01*predictionBreakdown$TP+10*predictionBreakdown$TN+0.01*predictionBreakdown$FP, decreasing=T, index.return=T)
  barplot(cbind(TP[aa$ix], TN[aa$ix], FP[aa$ix], FN[aa$ix]) ~ familyNames[aa$ix],data=predictionBreakdown,
          col=hcl.colors(4,"Temps"), las=2, xlab="", legend.text=c("TP","TN","FP","FN"),
          names.arg=familyNames[aa$ix], #substr(familyNames[aa$ix],1,7),
          ylab="Fraction of observations", args.legend = list(x = "bottomleft"))
  abline(h=mean((predictionBreakdown$TP+predictionBreakdown$TN)))
  dev.off()
}

if (createFigures){ # Fig. 3
  pdf(file="Fig3ab.pdf", width=30/2.54, height=15/2.54)
  par(mfrow=c(1,2))
  kol<- colorRampPalette(c("yellow","red","black")); kol <- kol(30)
  plot(familyRichness, Thur, colLevels=c(0,30),min_lwd=0.2,max_lwd=2); title("Family richness")
  points(X_site, Y_site, pch=21, cex=0.75, bg=kol[familyRichnessData[order(site_key)]])

  kols <- c("red","orange","yellow","green","blue")
  plot(IBCH.cat, Thur, colPalette=kols, discreteLevels=T, min_lwd=0.2,max_lwd=2); title("IBCH index")
  points(measured.IBCH.data$X, measured.IBCH.data$Y, pch=21, cex=0.75,
         bg=kols[measured.IBCH.data$IBCH_5])
  dev.off()

  pdf(file="Fig3c.pdf",width=15/2.54,height=15/2.54)
  plot(oeko[features4comparison,"OEKOMKLASS"], main="",reset=F,
       pal=c("gray","darkred","darkorange","gold","chartreuse4","darkslateblue"),
       xlim=range(Thur$CM$XContour[[1]][[1]]), ylim=range(Thur$CM$YContour[[1]][[1]]))
  lines(Thur$CM$XContour[[1]][[1]], Thur$CM$YContour[[1]][[1]])
  dev.off()}

if (createFigures){ # Fig. 4
  pdf(file="Fig4.pdf", width=24/2.54,height=12/2.54)
  par(mfrow=c(1,2))
  # Fig. 4a
  df <- data.frame(measured.IBCH=measured.IBCH.data$IBCH_20[-20],            # remove site 20 as its reach is not contained in the extracted river network
                   predicted.IBCH=IBCH.value[measured.IBCH.data$AGnode[-20]])

  lmodIBCH20_0 <- lm( measured.IBCH ~ predicted.IBCH, data=df)
  ssIBCH_0 <- summary(lmodIBCH20_0)
  plotFit(lmodIBCH20_0, data=df, col="black", pch=19, shade=T, interval="confidence",
          xlim=c(0,18), ylim=c(0,18),bty="n",xaxt="n",yaxt="n",ylab="Measured IBCH",
          xlab="Predicted IBCH")
  axis(1, pos=0, at=seq(0,18,3)); axis(2, pos=0, at=seq(0,18,3));
  abline(h=c(4.5,8.5,12.5,16.5),v=c(4.5,8.5,12.5,16.5),col="gray80")
  title(sprintf("y =  %.2f x  + %.2f -   p: %.1e   -   R2: %.2f",
                ssIBCH_0$coefficients[2,1],
                ssIBCH_0$coefficients[1,1],ssIBCH_0$coefficients[2,4], ssIBCH_0$adj.r.squared))
  polygon(c(0,4.5,4.5,0,0),c(0,0,4.5,4.5,0),col=rgb(1,0,0,0.5), border=NA)
  polygon(c(4.5,8.5,8.5,4.5,4.5),c(4.5,4.5,8.5,8.5,4.5),col=rgb(1,0.647,0,0.5), border=NA)
  polygon(c(8.5,12.5,12.5,8.5,8.5),c(8.5,8.5,12.5,12.5,8.5),col=rgb(1,1,0,0.5), border=NA)
  polygon(c(12.5,16.5,16.5,12.5,12.5),c(12.5,12.5,16.5,16.5,12.5),col=rgb(0,1,0,0.5), border=NA)
  polygon(c(16.5,18,18,16.5,16.5),c(16.5,16.5,18,18,16.5),col=rgb(0,0,1,0.5), border=NA)

  # Fig. 4b
  imagePlot(3:18, 2:6, t(compare.mat20[2:6,3:18]), col=hcl.colors(1000,"Blues 3",rev=T),
            zlim=c(0,0.12), ylab="Ecomorphological status", xlab="predicted IBCH",
            xaxt="n",yaxt="n")
  axis(2,pos=2.5); axis(1,pos=1.5,at=seq(3,18,3))
  polygon(c(x_val,rev(x_val)), c(qq[1,],rev(qq[2,])), col="#BBBBBB99", border=NA)
  abline(a=ss20$coefficients[1,1], b=ss20$coefficients[2,1])
  title(sprintf("y = %.2f + %.2f x  -   R2: %.2f",ss20$coefficients[1,1],
                ss20$coefficients[2,1], ss20$adj.r.squared))
  dev.off()}

if (createFigures){ # Fig. 1
  OCN <- OCN_300_4out_PB_hot
  OCN <- landscape_OCN(OCN)
  OCN <- aggregate_OCN(OCN, maxReachLength = 400)

  pdf("Fig1.pdf", width=25/2.54, height=13/2.54)
  par(mfrow=c(1,3))
  set.seed(1); theme1 <- sample(1:5,OCN$AG$nNodes, replace=T, prob=c(0.15,0.2,0.25,0.2,0.15))
  dN <- OCN$AG$downNode
  dN[dN==0] <- which(dN==0)
  t1 <- round((theme1 + theme1[dN] +0.1)/2)
  draw_thematic_OCN(OCN, t1, colPalette = kols, chooseCM=TRUE,
                    discreteLevels = T, exactDraw = T, addLegend = FALSE)

  set.seed(2); theme2 <- sample(1:5,OCN$AG$nNodes, replace=T, prob=c(0.1,0.2,0.3,0.2,0.1))
  t2 <- round((theme2 + theme2[dN] +0.1)/2)
  pal <- c("darkred","darkorange","gold","chartreuse4","darkslateblue")
  draw_thematic_OCN(OCN, t2, colPalette = pal, chooseCM=TRUE,
                    discreteLevels = T, exactDraw = T, addLegend = FALSE)

  draw_thematic_OCN(OCN, chooseCM=TRUE, exactDraw=TRUE)
  set.seed(5); s3 <- sample(which(OCN$AG$toCM==1), 30)
  t3 <- sample(5,length(s3), prob=c(0.1,0.2,0.3,0.2,0.1), replace = TRUE)
  points(OCN$AG$X[s3], OCN$AG$Y[s3], pch=21, cex=1.5,
         bg=kols[t3])
  dev.off()
}

if (createFigures){ # Fig. S1
  pdf("FigS1.pdf", width=24/2.54, height=11/2.54)
  boxplot(t(correctPredictions),
          ylab="Accuracy (TP + FP)",
          xlab="Threshold for P/A splitting", notch=T)
  dev.off()
}
